title: Euler 1 & 2
date: 2020-05-16
author: Harry
category: development, f#

# Euler 1

The first Euler problem is to get the sum of all multiples of 3 or 5 below 1000.

The first thing we need is a list of the numbers below 1000, which in F# is quite simple:

    [1..999]

Then, a function to filter the list for multiples of 3 or 5:

    let filterAndAdd listToFilter =
    	listToFilter 
    	|> List.filter mulipleOfThreeOrFive

We define a function `filterAndAdd` which takes a `listToFilter`, and passes it straight to the `List.filter` function, which filters using the `multipleOfThreeOrFive` function, and returns the results.

The `List.filter` function takes a list, and a function which returns true when applied to a list element which is to be selected, and false otherwise. 

The `multipleOfThreeOrFive` function exemplifies **function composition**:

    let multipleOf factor multiple = multiple % factor = 0
    
    let mulipleOfThreeOrFive element = 
    	multipleOf 3 element || multipleOf 5 element

The `multipleOf` function takes two arguments `factor` and `multiple` returns true if the multiple divided by the factor is 0, and false otherwise.	

The `multipleOfThreeOrFive` function takes an `element` (the multiple) and passes to it the `multipleOf` function along with either 3 or 5 as the factor, on either side of a bitwise OR, returning true if the `element` is a multiple of either 3 or 5.

Next, we need a function to sum a list of integers:

    let sumList list = List.reduce (+) list

`sumList` takes a list, and reduces it over the `+` operator.

Now we can pipe the result of `multipleOfThreeOrFive` to `sumList`:

    let filterAndAdd listToFilter =
    	listToFilter 
    	|> List.filter mulipleOfThreeOrFive
    	|> sumList

Now create the entry point, pass in the initial list to be printed:

    [<EntryPoint>]
    let main argv =
      printfn "Euler 1: %i" (EulerOne.filterAndAdd [1..999])
      0


<a id="orgb0831bb"></a>

# Euler 2

Euler problem 2 is to sum the evens in the Fibbonaci up to 4,000,000.

First we need to generate a Fibbonaci sequence. I stole this from someone on stackoverflow:

    // generate an infinite Fibonacci sequence
    // from: https://stackoverflow.com/questions/2845744/generating-fibonacci-series-in-f
    let fibSeq =    
        let rec fibseq n1 n2 = // recursive fibseq takes 2 params
    	    seq { let n0 = n1 + n2 // define sequence and calculate start
    	          yield n0 // yield start
    	          yield! fibseq n0 n1 } // merge with seq generated by fibseq
            seq { yield 1I ; yield 1I ; yield! (fibseq 1I 1I) } // return seq whose t3 is fibseq(t1, t2)

Its pretty nice. I will let you read the stackoverflow for that one.

The rest is much as with Problem 1, filtering and summing. The only issue I encountered was the requirement to handle `BigIntegers`, which I solved by specifying types and parsing wherever required:

    //  filter for evens, take the first limit numbers in the sequence, and convert to a list
    let fibGen (limit:int) = 
    	fibSeq 
    	|> Seq.filter (fun x -> (x % BigInteger(2)) = BigInteger(0))
    	|> Seq.takeWhile (fun x -> (x <= BigInteger(limit)))
    	|> Seq.toList
    
    let fibSum limit = 
    	fibGen limit
    	|> sumList

The whole file looks like:

    open System
    open System.Numerics
    
    module EulerOne = 
    
        let sumList list = List.reduce (+) list
    
        let multipleOf factor multiple = multiple % factor = 0
    
        let mulipleOfThreeOrFive element = 
    	        multipleOf 3 element || multipleOf 5 element
    
        let filterAndAdd listToFilter =
    	        listToFilter 
    	        |> List.filter mulipleOfThreeOrFive
    	        |> sumList 
    
    
    module EulerTwo =
    
        let sumList (list:List<BigInteger>) :BigInteger = List.sum list
    
        // generate an infinite Fibonacci sequence
        // from: https://stackoverflow.com/questions/2845744/generating-fibonacci-series-in-f
        let fibSeq =    
    	    let rec fibseq n1 n2 = // recursive fibseq takes 2 params
    	        seq { let n0 = n1 + n2 // define sequence and calculate start
    		      yield n0 // yield start
    		      yield! fibseq n0 n1 } // merge with seq generated by fibseq
    	    seq { yield 1I ; yield 1I ; yield! (fibseq 1I 1I) } // return seq whose t3 is fibseq(t1, t2)
    
    
        //  filter for evens, take the first limit numbers in the sequence, and convert to a list
        let fibGen (limit:int) = 
    	    fibSeq 
    	    |> Seq.filter (fun x -> (x % BigInteger(2)) = BigInteger(0))
    	    |> Seq.takeWhile (fun x -> (x <= BigInteger(limit)))
    	    |> Seq.toList
    
        let fibSum limit = 
    	    fibGen limit
    	    |> sumList
    
    
    [<EntryPoint>]
    let main argv =
      printfn "Euler 1: %i" (EulerOne.filterAndAdd [1..999])
      printfn "Euler 2: %A" (EulerTwo.fibSum 4000000)
      0
